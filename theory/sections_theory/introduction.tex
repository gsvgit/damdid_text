\section{Introduction}

Context-free path querying (CFPQ) allows one to use context-free grammars to specify constraints on paths in edge-labeled graphs. Compared to regular path queries (RPQ), CFPQ is strictly more expressive: for instance, a context-free grammar can be built to find siblings or same-generation categories in a taxonomy~\cite{Azimov:2018:CPQ:3210259.3210264,Kuijpers:2019:ESC:3335783.3335791}. This expressiveness allows CFPQ to be used for graph analysis in such areas as bioinformatics (hierarchy analysis~\cite{zhangCfPgRdf}, similarity queries~\cite{SubgraphQueriesbyContextfreeGrammars}), data provenance analysis~\cite{8731467}, static code analysis~\cite{Zheng,10.1145/373243.360208}. Although a lot of algorithms for CFPQ have been proposed, poor performance on real-world graphs and bad integration with real-world graph databases and graph analysis systems are still problems that hinder the adoption of CFPQ.

The problem with the performance of the CFPQ algorithms in real-world scenarios was pointed out by Jochem Kuijpers~\cite{Kuijpers:2019:ESC:3335783.3335791} as a result of an attempt to extend the Neo4j graph database with CFPQ. Several algorithms, based on such techniques as LR parsing algorithm~\cite{santosBottomUp}, dynamic programming~\cite{hellingsRelational}, LL parsing algorithm~\cite{10.1145/3167132.3167265}, linear algebra~\cite{Azimov:2018:CPQ:3210259.3210264}, were implemented, using Neo4j as a graph storage, and evaluated. None of them were performant enough to be used in real-world applications.   

Since Jochem Kuijpers pointed out the performance problem, it was shown that linear-algebra-based CFPQ algorithms, which operate over the adjacency matrix of the input graph and utilize parallel algorithms for linear algebraic operations, demonstrate good performance~\cite{10.1145/3398682.3399163}. Moreover, the matrix-based CFPQ algorithm is a base for the first full-stack support of CFPQ by extending the RedisGraph graph database~\cite{10.1145/3398682.3399163}.  

However, adjacency matrix is not the only possible format for graph representation, and data format conversion may take a lot of time; thus, it is not applicable in some cases. As a result, the development of the performant CFPQ algorithm for graph representations not based on matrices and its integration with real-world graph databases is still an open problem. Moreover, while the \textit{all pairs context-free constrained reachability} is widely discussed in the community, such practical cases as the \textit{all-paths} queries and the \textit{multiple sources} queries are not studied enough.

Additionally, almost all existing solutions are for \textit{reachability-only} problem. Recently, Jelle Hellings in~\cite{Hellings2020ExplainingPQ} and Rustam Azimov in~\cite{10.1145/3461837.3464513} have proposed algorithms that allow one to extract paths that satisfy the specified context-free constraints. The ability to extract paths of interest is important for some applications where the user wants to know not only the fact that one vertex is reachable from another one, but also to get a detailed explanation of why this vertex is reachable. One of such applications is a program code analysis where the fact is a potential problem in code, and paths can help to analyze and fix this problem. While the utilization of the general-purpose graph databases for code analysis is gaining popularity~\cite{9064792}, CFPQ algorithms that provide a structural representation of paths are not studied enough. 

Generalized LL (GLL) is a parsing algorithm that can handle any context-free grammar, including left-recursive and ambiguous ones. Similar to GLR (e.g. Tomita algorithm), it achieves this by using a graph-structured stack (GSS) to efficiently share and manage the parsing state, allowing it to explore all possible derivations in parallel without an exponential time cost. The output of the parsing is a compact representation of all possible parse trees for the input, known as a \textit{parse forest}. It was shown that the GLL algorithm can be naturally generalized to the CFPQ algorithm~\cite{Grigorev:2017:CPQ:3166094.3166104}. Moreover, this provides a natural solution not only for the \textit{reachability-only} problem but also for the \textit{all-paths} problem. At the same time, there exists a high-performance GLL parsing algorithm~\cite{AfroozenFasterGll} and its implementation in the Iguana project~\cite{iguana-parser}. 

Additionally, pure context-free grammars in Backus-Naur Form (BNF) are too verbose to express complex constraints. However, almost all algorithms require a query to be in such form. At the same time, Extended Backus-Naur Form (EBNF) can be used to specify context-free languages. EBNF allows combining typical regular expressions with mutually recursive rules which are required to specify context-free languages. That makes EBNF more user-friendly. But there are no CFPQ algorithms that utilize EBNF for query specification.

In this paper, we generalize the GLL parsing algorithm to handle queries in EBNF without its transformation. We show that it allows us to increase the performance of the query evaluation. We also integrate our solution with the Neo4j graph database and evaluate it. Thus, we make the following contributions in this paper.
\begin{itemize}
    \item We propose the GLL-based CFPQ algorithm that can handle queries in Extended Backus-Naur Form without transformation. Our solution utilizes Recursive State Machines (RSM)~\cite{10.1145/1075382.1075387} for it. The proposed algorithm can be used to solve both the \textit{reachability-only} and the \textit{all-paths} problems.
    \item We provide an implementation of the proposed CFPQ algorithm. By experimental study on real-world graphs we show that utilization of RSMs allows one to increase performance of the query evaluation. 
    \item We integrate the implemented algorithm with Neo4j by providing a respective stored procedure that can be called from Cypher. Currently, we use Neo4j as a graph storage and do not extend Cypher to express context-free path patterns. Thus, expressive power of our solution is limited: we cannot use the full power of Cypher within our constraints. Implementing a query language extension amounts to a lot of additional effort and is a part of future work.
    \item We evaluate the proposed solution on several real-world graphs. Our evaluation shows that the proposed solution in order of magnitude is faster than a similar linear algebra-based solution for RedisGraph. Moreover, we show that our solution is compatible with native Neo4j solution for RPQs, and in some cases requires significantly less memory. Note that while Cypher's expressively is limited, our solution can handle arbitrary RPQs.
\end{itemize}

The paper has the following structure. In section~\ref{section:preliminaries} we introduce basic notions and definitions from graph theory and formal language theory. Then, in section~\ref{section:RSM} we introduce \textit{recursive state machines} and provide an example of the CFPQ evaluation using na{\"{\i}}ve strategy which may lead to infinite computations. Section~\ref{section:GLL-CFPQ} contains a description of the GLL-based CFPQ evaluation algorithm which uses RSM and solves problems of the na{\"{\i}}ve strategy from the previous section: the algorithm always terminates and can build a finite representation of all paths of interest. Section~\ref{section:dataset} introduces a data set (both graphs and queries) which will be used further for experiments. Further, in section~\ref{section:BFN_or_RSM} we use this data set to compare different versions of the GLL-based CFPQ algorithm. After that, in section~\ref{section:cfpq_for_neo4j} we provide details on the integration of the best version into the Neo4j graph database, and evaluate our solution on the data set introduced before. Related work is discussed in section~\ref{section:related_work}. Final remarks and conclusion are provided in section~\ref{section:conclusion}.