\section{Performance of GLL on Queries in BNF and EBNF}\label{section:BFN_or_RSM}

As discussed above, different CFG representations can be used to define the query. The basic one is BNF, the more expressive (but not more powerful) is EBNF. EBNF can also speed up query evaluation by replacing some recursion with Kleene star, reducing stack usage. RSMs natively encode EBNF grammars and can be processed by GLL~\ref{section:RSM}.

We implemented and evaluated two versions of the GLL-based CFPQ algorithm~\cite{kotgll}: one operates with grammar in BNF, and another one operates with grammar in EBNF and utilizes RSM to represent it. Both versions were evaluated in reachability-only mode to estimate performance differences and to choose the best one to integrate with Neo4j. 

\mycomment{
\subsection{Implementation Details}
The modification of the GLL algorithm to operate with the grammar in EBNF is based on replacing \emph{positions in the grammar} in the descriptor with the state of a recursive automaton.
%in other words in tuple $\langle \langle A \rightarrow \alpha, c_{\alpha} \rangle, c_{u }, c_{i}, c_{N} \rangle$ pair $\langle A \rightarrow \alpha, c_{\alpha} \rangle$ is replaced by $c_{R}$ which is the current state of the recursive automaton.
Accordingly, the transition in a context-free grammar is replaced with a transition in a recursive automaton.

Our modification, like the classic GLL algorithm, can be generalized to graphs. At the transition step in the recursive automaton, all transitions from the current state of the recursive automaton are processed along with all outgoing edges of the current vertex of the graph.

To make the implementation code itself as concise and understandable as possible for further extensions and optimizations, Kotlin was chosen as a programming language for implementing.
}

\subsection{Evaluation}\label{section:cfg_vs_rsm}

To assess the applicability of the proposed solution, we evaluate it on a number of real-world graphs and queries described in section~\ref{section:dataset}.
We evaluate \textit{reachability-only} query performance across varying start-set sizes to estimate the speedup of the RSM-based approach over the BNF-based one.
The experimental study was conducted as follows.   

\begin{itemize}
    \item For all graphs, queries, and start vertex sets, described in section~\ref{section:dataset}, we measure evaluation time for both versions.
    \item Average time for each start vertex set size was calculated. Thus, for each graph, query, and start vertex set size, we have an average time of respective query evaluation.
    \item Speedup as a ratio of BNF-based version evaluation time to RSM-based version evaluation time was calculated.
\end{itemize}


Results are shown in Fig.~\ref{fig:speedup}. In most cases, the RSM-based version outperforms the BNF-based one, with speedups typically below 2 times but reaching over 5 times in some settings (Fig.~\ref{fig:speedup} c: graph \textit{pathways}, grammar \textit{Geo}). The mean speedup across all graphs and grammars is 1.5, indicating that RSM-based GLL is faster on average.


\newcommand\speedImageW{0.34}
\newcommand\speedImageScale{1.111}


\begin{figure}[htbp]%
    \centering%
    \begin{minipage}{\speedImageW\textwidth} % 
        \centering % 
        \includegraphics[width=\speedImageScale\textwidth]{figures/g1_kotgll_result.eps}
        \small (a) 
    \end{minipage}%
    \begin{minipage}{\speedImageW\textwidth}%
        \centering%
        \includegraphics[width=\speedImageScale\textwidth]{figures/g2_kotgll_result.eps}
        \small (b) 
    \end{minipage}%
    \begin{minipage}{\speedImageW\textwidth}%
        \centering%
        \includegraphics[width=\speedImageScale\textwidth]{figures/geo_kotgll_result.eps}
        \small (c)
    \end{minipage}%
    \caption{Multiple-source CFPQ reachability speedup (RSM over CFG) on RDF graphs for (a)~$G_1$, (b)~$G_2$, and (c)~$Geo$ queries.}
    \label{fig:speedup}
\end{figure}