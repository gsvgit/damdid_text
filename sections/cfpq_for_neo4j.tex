\section{CFPQ For Neo4j}\label{section:cfpq_for_neo4j}

This section details integrating GLL-based CFPQ into the Neo4j graph database. We use the RSM-based variant because our comparison (Section~\ref{section:cfg_vs_rsm}) shows it outperforms the BNF-based one.
Also, we provide results of the implemented solution evaluation which show that, first of all, the provided solution is faster than a similar linear algebra-based solution for RedisGraph. In addition, we show that on RPQs our solution is compatible with the Neo4j native one and in some cases evaluates queries successfully while the native solution fails with an \textit{OutOfMemory} exception.

\subsection{Implementation Details}

Neo4j stored procedure is a mechanism through which query language can be extended by writing custom code in Java in such a way that it can be called directly via Cypher. %The Java code need to be compiled into a \texttt{jar} file and to be put in the plugins directory of Neo4j root folder. 

We implemented a Neo4j stored procedure which solves the reachability problem for the given set of the start vertices and the given query. The procedure can be called as follows:
$\texttt{CALL}~\texttt{cfpq.gll.getReachabilities(nodes, q)}$
where \texttt{nodes} is a collection of start nodes, and \texttt{q} is a string representation (or description) of RSM specified over relation types. The procedure outputs a stream of reachable node pairs. Note that the expressive power of our solution is limited: we cannot use the full power of Cypher inside our constraints. For example, we cannot specify constraints on the vertices inside our constraints.

\mycomment{
%\scalebox{0.75}{\parbox{.5\linewidth}{%
\begin{align*}
StartState(&id=0,nonterminal=Nonterminal(S),\\
           &isStart=true,isFinal=false) \\
State(&id=1,nonterminal=Nonterminal(S), \\
      &isStart=false,isFinal=false) \\
State(&id=4,nonterminal=Nonterminal(S),isStart=false,isFinal=false) \\
State(&id=3,nonterminal=Nonterminal(S),isStart=false,isFinal=true) \\
State(&id=2,nonterminal=Nonterminal(S),isStart=false,isFinal=false) \\
State(&id=5,nonterminal=Nonterminal(S), \\
      &isStart=false,isFinal=false) \\
TerminalEdge(&tail=0,head=1,terminal=Terminal(subClassOf\_r)) \\
TerminalEdge(&tail=0,head=4,terminal=Terminal(type\_r)) \\
TerminalEdge(&tail=1,head=3,terminal=Terminal(subClassOf)) \\
NonterminalEdge(&tail=1,head=2,nonterminal=Nonterminal(S)) \\
TerminalEdge(&tail=4,head=3,terminal=Terminal(type)) \\
NonterminalEdge(&tail=4,head=5,nonterminal=Nonterminal(S)) \\
TerminalEdge(&tail=2,head=3,terminal=Terminal(subClassOf)) \\
TerminalEdge(&tail=5,head=3,terminal=Terminal(type))
\end{align*}
}
%}}
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.47\textwidth]{architecture.pdf}
%     \caption{Architecture of the solution}
%     \label{fig:solution_architecture}
% \end{figure}

We implemented a wrapper for Neo4j. Communication with the database is done using the Neo4j Native Java API. So, we used an embedded database, which means it is run inside of the application and is not used as an external service.

Along with the existing modifications of GLL, we made a Neo4j-specific one. Neo4j return result should be represented as a \texttt{Stream} and it is important to prevent early stream forcing, thus we changed all GLL internals to ensure that. This also has an added benefit that the query result is a stream, and thus it is possible to get the results on demand. 

\subsection{Evaluation}

To assess the applicability of the proposed solution, we evaluate it on a number of real-world graphs and queries. To estimate relative performance, we compare our solution with the matrix-based CFPQ algorithm implemented in RedisGraph by Arseniy Terekhov et al in~\cite{DBLP:conf/edbt/TerekhovPAZG21}. Also, we compare the performance of the query evaluation in \textit{reachability-only} mode on regular path queries with the native Neo4j solution.

%\subsection{Evaluation Results}

The results of the context-free path query evaluations are presented in Fig.~\ref{fig:performance}. 
Evaluation time depends not only on graph size and sparsity, but also on graph structure. 
For example, a relatively small graph \textit{go\_hierarchy} fully consists of edges used in queries $G_1$ and $G_2$, thus evaluation time for these queries is significantly bigger than for some bigger but more sparse graphs, for example, for the \textit{eclass} graph. Especially for a relatively large starting vertex set. Note that the creation of the relevant metrics for the CFPQ query evaluation time prediction is a challenging problem by itself and should be tackled in the future.

In almost all cases, the proposed solution is significantly faster than RedisGraph (in orders of magnitude in some cases).
In some cases, however (e.g., graph \textit{core} across all queries), RedisGraph outperforms our solution. Moreover, it can be seen that evaluation time for RedisGraph is more predictable. For our solution, in some cases, execution time highly depends on the start set. For example, see Fig.~\ref{fig:performance}~c, graph \textit{enzyme}.    

\newcommand\squeryImageW{0.34}
\newcommand\squeryImageScale{1.111}
\begin{figure}
    \begin{minipage}{\squeryImageW\textwidth}
        \centering
        \includegraphics[width=\squeryImageScale\textwidth]{figures/g1_result.eps}
        \small{(a)}
    \end{minipage}%
    \begin{minipage}{\squeryImageW\textwidth}
        \centering
    \includegraphics[width=\squeryImageScale\textwidth]{figures/g2_result.eps}
    \small{(b)}
    \end{minipage}%
    \begin{minipage}{\squeryImageW\textwidth}
        \centering
    \includegraphics[width=\squeryImageScale\textwidth]{figures/geo_result.eps}
    \small{(c)}
    \end{minipage}%
    \caption{Multiple source CFPQ reachability results for the queries: (a)~$G_1$, (b)~$G_2$, (c)~$Geo$ related to RDF analysis.}
    \label{fig:performance}
\end{figure}


The particularly important scenario is when the start set contains a single vertex. \texttt{Single-source reachability} queries are reasonably fast: median runtime is about few milliseconds across all graphs and queries. Even in this setting, runtime depends strongly on graph structure. For example, \textit{core} is slower than the other graphs despite being the smallest by node and edge count. Predicting execution time with a reliable metric remains non-trivial. As expected, runtime increases with chunk size.


Partial results for RPQ evaluation are presented in Fig.~\ref{fig:performance-reg}. For queries $\textit{reg}_3$ (defined in~\ref{eqn:reg_3}) and $\textit{reg}_4$ (defined in~\ref{eqn:reg_4}) we get similar results. Note that on \textit{geospecies} and \textit{taxonomy} graphs, the native solution failed with the \textit{OutOfMemory} exception, while our solution evaluates queries successfully. 

\begin{figure}
    \begin{minipage}{0.4\textwidth}
        \includegraphics[width=1.0125\textwidth]{figures/reg1_rpq_result.eps}
        \small{(a)}
    \end{minipage}%
    \begin{minipage}{0.4\textwidth}
        \includegraphics[width=1.0125\textwidth]{figures/reg2_rpq_result.eps}
        \small{(b)}
    \end{minipage}%   
    \centering
    \caption{Multiple source RPQ reachability results for queries related to RDF analysis: (a)~$\textit{reg}_1$ query, (b)~$\textit{reg}_2$ query (native solution failed with OOM on the last two graphs).}
    \label{fig:performance-reg}
\end{figure}


We can see that the proposed solution is slightly slower than the native Neo4j algorithm, but not dramatically: typically less than two times. Moreover, in some cases, our solution is comparable with the native one (see Fig.~\ref{fig:performance-reg}~a and Fig.~\ref{fig:performance-reg}~b, graph \textit{eclass}), and in some cases, our solution is faster than the native one (see Fig.~\ref{fig:performance-reg}~b, graph \textit{core}).

Finally, we conclude that the proposed GLL-based solution can serve as an alternative to linear algebra-based CFPQ algorithms and is suitable for real-world graph analysis systems: our evaluation shows that the proposed solution outperforms the linear algebra-based one. Furthermore, we show that the proposed solution can be used as a universal algorithm for both RPQ and CFPQ.